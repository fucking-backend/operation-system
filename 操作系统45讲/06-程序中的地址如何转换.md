##  虚幻与真实：程序中的地址如何转换？

虚拟地址和物理地址的关系和转换机制

### 从一个多程序并发的场景说起

两个程序A、B并发执行：

1. 谁来保证程序 A 跟程序 B 没有**内存地址的冲突**？换句话说，就是程序 A、B 各自放在什么内存地址，这个问题是由 A、B 程序协商，还是由操作系统决定。

2. 怎样保证程序 A 跟程序 B **不会互相读写各自的内存空间**？这个问题相对简单，用保护模式就能解决。

3. 如何解决**内存容量**问题？程序 A 和程序 B，在不断开发迭代中程序代码占用的空间会越来越大，导致内存装不下。

4. 还要考虑一个**扩展**后的复杂情况，如果不只程序 A、B，还可能有程序 C、D、E、F、G……它们分别由不同的公司开发，而每台计算机的内存容量不同。这时候，又对我们的内存方案有怎样的影响呢？

【虚拟地址】：让所有的程序都各自享有一个从 0 开始到最大地址的空间，这个地址空间是独立的，是该程序私有的，其它程序既看不到，也不能访问该地址空间，这个地址空间和其它程序无关，和具体的计算机也无关。

### 虚拟地址

那么这个地址是由谁产生的呢？

答案是【链接器】，其实我们开发软件经过编译步骤后，就需要链接成可执行文件才可以运行，而链接器的主要工作就是把多个代码模块组装在一起，并解决模块之间的引用，即处理程序代码间的地址引用，形成程序运行的静态内存空间视图。

### 物理地址

虽然虚拟地址解决了很多问题，但是虚拟地址只是逻辑上存在的地址，无法作用于硬件电路的，程序装进内存中想要执行，就需要和内存打交道，从内存中取得指令和数据。而内存只认一种地址，那就是物理地址。

### 虚拟地址到物理地址的转换：MMU

**把虚拟地址空间和物理地址空间都分成同等大小的块，也称为页，按照虚拟页和物理页进行转换**。根据软件配置不同，这个页的大小可以设置为 4KB、2MB、4MB、1GB，这样就进入了现代内存管理模式——**分页模型**。


### MMU & 页表（多级页表）

### 保护模式下的分页（4KB、4MB） & 长模式下的分页（4KB、2MB）

### MMU 地址转换失败(😅)

    1.MMU 停止转换地址。
    2.MMU 把转换失败的虚拟地址写入 CPU 的 CR2 寄存器。
    3.MMU 触发 CPU 的 14 号中断，使 CPU 停止执行当前指令。
    4.CPU 开始执行 14 号中断的处理代码，代码会检查原因，处理好页表数据返回。
    5.CPU 中断返回继续执行 MMU 地址转换失败时的指令。

## 思考题

在分页模式下，操作系统是如何对应用程序的地址空间进行隔离的？

实模式下多个任务共享所有地址空间太危险，因此才有了保护模式，保护模式下的分页模式是一个巨大的创新。
对于每个进程而言，它会误认为(被操作系统欺骗)自己独有所有地址空间，因此它访问地址是不会考虑任何问题的，可是这个地址是虚拟地址，待被MMU翻译后会得到对应的页表，而这个页表由操作系统管理，不同的进程拥有不同的页表，也因此产生了进程地址空间隔离，但是多个进程也是可以共享某个页表，这也是进程通信(IPC)的根本手段。
