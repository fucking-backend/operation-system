##  【内存】虚幻与真实：程序中的地址如何转换？

### 从一个多程序并发的场景说起

两个程序A、B并发执行：

1. 谁来保证程序 A 跟程序 B 没有**内存地址的冲突**？换句话说，就是程序 A、B 各自放在什么内存地址，这个问题是由 A、B 程序协商，还是由操作系统决定。

2. 怎样保证程序 A 跟程序 B **不会互相读写各自的内存空间**？这个问题相对简单，用保护模式就能解决。

3. 如何解决**内存容量**问题？程序 A 和程序 B，在不断开发迭代中程序代码占用的空间会越来越大，导致内存装不下。

4. 还要考虑一个**扩展**后的复杂情况，如果不只程序 A、B，还可能有程序 C、D、E、F、G……它们分别由不同的公司开发，而每台计算机的内存容量不同。这时候，又对我们的内存方案有怎样的影响呢？

【虚拟地址】：让所有的程序都各自享有一个从 0 开始到最大地址的空间，这个地址空间是独立的，是该程序私有的，其它程序既看不到，也不能访问该地址空间，这个地址空间和其它程序无关，和具体的计算机也无关。

### 虚拟地址

那么这个地址是由谁产生的呢？

答案是【链接器】，其实我们开发软件经过编译步骤后，就需要链接成可执行文件才可以运行，而链接器的主要工作就是把多个代码模块组装在一起，并解决模块之间的引用，即处理程序代码间的地址引用，形成程序运行的静态内存空间视图。

### 物理地址

虽然虚拟地址解决了很多问题，但是虚拟地址只是逻辑上存在的地址，无法作用于硬件电路的，程序装进内存中想要执行，就需要和内存打交道，从内存中取得指令和数据。而内存只认一种地址，那就是物理地址。

什么是物理地址呢？物理地址在逻辑上也是一个数据，只不过这个数据会被地址译码器等电子器件变成电子信号，放在地址总线上，地址总线电子信号的各种组合就可以选择到内存的储存单元了。

### 虚拟地址到物理地址的转换

**把虚拟地址空间和物理地址空间都分成同等大小的块，也称为页，按照虚拟页和物理页进行转换**。根据软件配置不同，这个页的大小可以设置为 4KB、2MB、4MB、1GB，这样就进入了现代内存管理模式——**分页模型**。

### MMU & 页表（多级页表）

MMU 即内存管理单元，是用硬件电路逻辑实现的一个地址转换器件，它负责接受虚拟地址和地址关系转换表，以及输出物理地址。

x86 CPU 要想开启 MMU，就必须先开启保护模式或者长模式，实模式下是不能开启 MMU 的。由于保护模式的内存模型是分段模型，它并不适合于 MMU 的分页模型，所以我们要使用保护模式的平坦模式，这样就绕过了分段模型。这个**平坦模型和长模式**下忽略段基址和段长度是异曲同工的

地址关系转换表，其实它有个更加专业的名字——**页表**。它描述了虚拟地址到物理地址的转换关系，也可以说是虚拟页到物理页的映射关系，所以称为页表。

为了增加灵活性和节约物理内存空间（因为页表是放在物理内存中的），所以页表中并不存放虚拟地址和物理地址的对应关系，只存放物理页面的地址，MMU 以虚拟地址为索引去查表返回物理页面地址，而且页表是分级的，总体分为三个部分：一个顶级页目录，多个中级页目录，最后才是页表

### 保护模式平坦模型下的分页（4KB、4MB） & 长模式下的分页（4KB、2MB）

分页大小的不同，会导致虚拟地址位段的分隔和页目录的层级不同，但虚拟页和物理页的大小始终是等同的。

### 开启MMU

### MMU 地址转换失败(😅)

    1.MMU 停止转换地址。
    2.MMU 把转换失败的虚拟地址写入 CPU 的 CR2 寄存器。
    3.MMU 触发 CPU 的 14 号中断，使 CPU 停止执行当前指令。
    4.CPU 开始执行 14 号中断的处理代码，代码会检查原因，处理好页表数据返回。
    5.CPU 中断返回继续执行 MMU 地址转换失败时的指令。

## 思考题

在分页模式下，操作系统是如何对应用程序的地址空间进行隔离的？

实模式下多个任务共享所有地址空间太危险，因此才有了保护模式，保护模式下的分页模式是一个巨大的创新。
对于每个进程而言，它会误认为(被操作系统欺骗)自己独有所有地址空间，因此它访问地址是不会考虑任何问题的，可是这个地址是虚拟地址，待被MMU翻译后会得到对应的页表，而这个页表由操作系统管理，**不同的进程拥有不同的页表**，也因此产生了进程地址空间隔离，但是多个进程也是可以共享某个页表，这也是进程通信(IPC)的根本手段。
